{"example" :  null, "\n    model.userData.rotationSpeed ": "3", "\n    model.userData.isMoving ": "false", "\n    model.userData.initialized ": "true", "\n    \n    // Create UI instructions\n    createHTML(`\n      <div id": null, "\n        bottom: 20px": null, "\n        left: 20px": null, "\n        background-color: rgba(0, 0, 0, 0.7)": null, "\n        color: white": null, "\n        padding: 10px": null, "\n        border-radius: 5px": null, "\n        font-family: Arial, sans-serif": null, "\n      \">\n        <h3>Controls</h3>\n        <p>W/A/S/D - Move the character</p>\n        <p>Space - Jump</p>\n      </div>\n    `)": null, "\n  }\n  \n  // Movement logic\n  let isMoving ": "false", "\n  const moveDirection ": "new THREE.Vector3(0, 0, 0)", "\n  \n  // Forward/backward movement\n  if (input.keys.w) {\n    moveDirection.z ": "-1", "\n    isMoving ": "true", "\n  } else if (input.keys.s) {\n    moveDirection.z ": "1", "\n  }\n  \n  // Left/right movement\n  if (input.keys.a) {\n    moveDirection.x ": "-1", "\n  } else if (input.keys.d) {\n    moveDirection.x ": "1", "\n  }\n  \n  // Normalize movement direction\n  if (moveDirection.length() > 0) {\n    moveDirection.normalize()": null, "\n  }\n  \n  // Apply movement\n  model.position.x +": "moveDirection.x * model.userData.speed * delta", "\n  model.position.z +": "moveDirection.z * model.userData.speed * delta", "\n  \n  // Handle rotation to face movement direction\n  if (isMoving) {\n    const targetRotation ": "Math.atan2(moveDirection.x, -moveDirection.z)", "\n    model.rotation.y ": "THREE.MathUtils.lerp(\n      model.rotation.y,\n      targetRotation,\n      model.userData.rotationSpeed * delta\n    )", "\n    \n    // Play running animation\n    playAnimation(model.name, 'run')": null, "\n  } else {\n    // Play idle animation when not moving\n    playAnimation(model.name, 'idle')": null, "\n  }\n  \n  // Jump logic\n  if (input.keys[' '] && !model.userData.isJumping) {\n    model.userData.isJumping ": "true", "\n    model.userData.jumpTime ": "0", "\n    playAnimation(model.name, 'jump')": null, "\n  }\n  \n  // Handle jump physics\n  if (model.userData.isJumping) {\n    model.userData.jumpTime +": "delta", "\n    \n    // Simple parabolic jump\n    const jumpHeight ": "2", "\n    const jumpDuration ": "1", "\n    const jumpProgress ": "model.userData.jumpTime / jumpDuration", "\n    \n    if (jumpProgress < 1) {\n      // Parabolic curve: 4 * h * t * (1 - t)\n      model.position.y ": "4 * jumpHeight * jumpProgress * (1 - jumpProgress)", "\n    } else {\n      model.position.y ": "0", "\n      model.userData.isJumping ": "false", "\n    }\n  }\n}\n\nreturn { update }": null, "\n\n// ": null, "\n    model.userData.cameraHeight ": "2", "\n    model.userData.cameraRotation ": "0", "\n    model.userData.cameraInitialized ": "true", "\n  }\n  \n  // Update camera rotation based on mouse movement if right mouse button is pressed\n  if (input.mouse.buttons[2]) {\n    // Store initial mouse position on right-click start\n    if (!model.userData.isDragging) {\n      model.userData.isDragging ": "true", "\n      model.userData.lastMouseX ": "input.mouse.x", "\n    }\n    \n    // Calculate mouse movement delta\n    const mouseDelta ": "input.mouse.x - model.userData.lastMouseX", "\n    model.userData.cameraRotation +": "mouseDelta * 0.01", "\n    model.userData.lastMouseX ": "input.mouse.x", "\n  } else {\n    model.userData.isDragging ": "false", "\n  }\n  \n  // Calculate camera position\n  const cameraOffset ": "new THREE.Vector3(\n    Math.sin(model.userData.cameraRotation) * model.userData.cameraDistance,\n    model.userData.cameraHeight,\n    Math.cos(model.userData.cameraRotation) * model.userData.cameraDistance\n  )", "\n  \n  // Set camera position relative to model\n  camera.position.copy(model.position).add(cameraOffset)": null, "\n  \n  // Make camera look at model\n  camera.lookAt(\n    model.position.x,\n    model.position.y + 1, // Look at head level\n    model.position.z\n  )": null, "\n}\n\nreturn { update }": null, "\n    model.userData.isHighlighted ": "false", "\n    model.userData.originalColor ": "null", "\n    model.userData.interactionDistance ": "3", "\n    model.userData.hasInteracted ": "false", "\n    \n    // Store original materials for highlighting\n    model.userData.originalMaterials ": "[]", "\n    model.traverse(child ": null, "\n        } else {\n          model.userData.originalMaterials.push(child.material.clone())": null, "\n        }\n      }\n    })": null, "\n  }\n  \n  // Find player model\n  const player ": "getModelByName('player.glb')", "\n  if (!player) return": null, "\n  \n  // Calculate distance to player\n  const distanceToPlayer ": "player.position.distanceTo(model.position)", "\n  \n  // Handle proximity highlighting\n  if (distanceToPlayer < model.userData.interactionDistance) {\n    // Highlight object when player is close\n    if (!model.userData.isHighlighted) {\n      model.userData.isHighlighted ": "true", "\n      \n      // Apply highlight material\n      model.traverse(child ": null, "\n              mat.emissiveIntensity ": "0.5", "\n            })": null, "\n          } else {\n            child.material.emissive ": "new THREE.Color(0x333333)", "\n            child.material.emissiveIntensity ": "0.5", "\n          }\n        }\n      })": null, "\n      \n      // Show interaction prompt\n      createHTML(`\n        <div id": null, "\n          top: 50%": null, "\n          left: 50%": null, "\n          transform: translate(-50%, -50%)": null, "\n          background-color: rgba(0, 0, 0, 0.7)": null, "\n          color: white": null, "\n          padding: 10px 20px": null, "\n          border-radius: 5px": null, "\n          font-family: Arial, sans-serif": null, "\n          pointer-events: none": null, "\n        \">\n          Click to interact\n        </div>\n      `)": null, "\n    }\n    \n    // Handle click interaction\n    if (input.mouse.buttons[0] && !model.userData.hasInteracted) {\n      // Perform interaction\n      model.userData.hasInteracted ": "true", "\n      \n      // Play animation if available\n      playAnimation(model.name, 'activate')": null, "\n      \n      // Show interaction result\n      removeHTML('interact-prompt')": null, "\n      createHTML(`\n        <div id": null, "\n          top: 30%": null, "\n          background-color: rgba(0, 0, 0, 0.8)": null, "\n          padding: 15px 25px": null, "\n        \">\n          <h3>Item Discovered!</h3>\n          <p>You found a mysterious artifact.</p>\n        </div>\n      `)": null, "\n      \n      // Remove the result after 3 seconds\n      setTimeout(() ": "> {\n        removeHTML('interaction-result')", "\n      }, 3000)": null, "\n    }\n  } else {\n    // Remove highlight when player moves away\n    if (model.userData.isHighlighted) {\n      model.userData.isHighlighted ": "false", "\n      \n      // Restore original materials\n      model.traverse(child ": null, "\n      \n      // Remove interaction prompt\n      removeHTML('interact-prompt')": null, "\n    model.userData.state ": "'patrol'", " // patrol, chase, talk\n    model.userData.speed ": "2", "\n    model.userData.patrolPoints ": "[\n      new THREE.Vector3(5, 0, 5),\n      new THREE.Vector3(-5, 0, 5),\n      new THREE.Vector3(-5, 0, -5),\n      new THREE.Vector3(5, 0, -5)\n    ]", "\n    model.userData.currentPatrolIndex ": "0", "\n    model.userData.detectionRadius ": "8", "\n    model.userData.interactionRadius ": "3", "\n    model.userData.dialogueActive ": "false", "\n    model.userData.dialogueStep ": "0", "\n    \n    // Set initial position to first patrol point\n    model.position.copy(model.userData.patrolPoints[0])": null, "\n  }\n  \n  // Find player\n  const player ": "getModelByName('player.glb')", "\n  \n  // State machine\n  switch (model.userData.state) {\n    case 'patrol':\n      // Get current patrol target\n      const targetPoint ": "model.userData.patrolPoints[model.userData.currentPatrolIndex]", "\n      \n      // Move towards target\n      const directionToTarget ": "new THREE.Vector3()\n        .subVectors(targetPoint, model.position)\n        .normalize()", "\n      \n      // Check if we've reached the target (within 0.5 units)\n      const distanceToTarget ": "model.position.distanceTo(targetPoint)", "\n      if (distanceToTarget > 0.5) {\n        // Move towards target\n        model.position.x +": "directionToTarget.x * model.userData.speed * delta", "\n        model.position.z +": "directionToTarget.z * model.userData.speed * delta", "\n        \n        // Rotate towards movement direction\n        const targetRotation ": "Math.atan2(directionToTarget.x, -directionToTarget.z)", "\n        model.rotation.y ": "THREE.MathUtils.lerp(\n          model.rotation.y,\n          targetRotation,\n          model.userData.rotationSpeed * delta\n        )", "\n        \n        // Play walking animation\n        playAnimation(model.name, 'walk')": null, "\n      } else {\n        // Move to next patrol point\n        model.userData.currentPatrolIndex ": "(model.userData.currentPatrolIndex + 1) % model.userData.patrolPoints.length", "\n        \n        // Play idle animation briefly\n        playAnimation(model.name, 'idle')": null, "\n      }\n      \n      // Check if player is detected\n      if (distanceToPlayer < model.userData.detectionRadius) {\n        model.userData.state ": "'chase'", "\n      }\n      break": null, "\n      \n    case 'chase':\n      // Move towards player\n      const directionToPlayer ": "new THREE.Vector3()\n        .subVectors(player.position, model.position)\n        .normalize()", "\n      \n      // Move towards player\n      model.position.x +": "directionToPlayer.x * model.userData.speed * 1.5 * delta", "\n      model.position.z +": "directionToPlayer.z * model.userData.speed * 1.5 * delta", "\n      \n      // Rotate towards player\n      const targetRotationToPlayer ": "Math.atan2(directionToPlayer.x, -directionToPlayer.z)", "\n      model.rotation.y ": "THREE.MathUtils.lerp(\n        model.rotation.y,\n        targetRotationToPlayer,\n        model.userData.rotationSpeed * delta\n      )", "\n      \n      // Play running animation\n      playAnimation(model.name, 'run')": null, "\n      \n      // Check if close enough to interact\n      if (distanceToPlayer < model.userData.interactionRadius) {\n        model.userData.state ": "'talk'", "\n        stopAnimation(model.name)": null, "\n        playAnimation(model.name, 'idle')": null, "\n      }\n      \n      // If player gets too far, go back to patrolling\n      if (distanceToPlayer > model.userData.detectionRadius * 1.5) {\n        model.userData.state ": "'patrol'", "\n      \n    case 'talk':\n      // Always face the player\n      const lookAtPlayer ": "new THREE.Vector3()\n        .subVectors(player.position, model.position)\n        .normalize()", "\n      const talkRotation ": "Math.atan2(lookAtPlayer.x, -lookAtPlayer.z)", "\n      \n      // Show dialogue if not already active\n      if (!model.userData.dialogueActive) {\n        model.userData.dialogueActive ": "true", "\n        \n        // Display dialogue based on current step\n        const dialogues ": "[\n          \"Hello traveler! Welcome to our village.\",\n          \"I haven't seen you around here before.\",\n          \"Be careful in the forest to the north. Strange things have been happening there.\",\n          \"If you need supplies, visit the merchant by the town square.\"\n        ]", "\n        \n        createHTML(`\n          <div id": null, "\n            bottom: 100px": null, "\n            left: 50%": null, "\n            transform: translateX(-50%)": null, "\n            background-color: rgba(0, 0, 0, 0.8)": null, "\n            color: white": null, "\n            padding: 15px 25px": null, "\n            border-radius: 5px": null, "\n            font-family: Arial, sans-serif": null, "\n            max-width: 80%": null, "\n            text-align: center": null, "\n          \">\n            <p>${dialogues[model.userData.dialogueStep]}</p>\n            <div style": "\"\n              margin-top: 10px", "\n              font-size: 0.8em": null, "\n              color: #aaa": null, "\n            \">Click to continue</div>\n          </div>\n        `)": null, "\n        \n        // Play talking animation\n        playAnimation(model.name, 'talk')": null, "\n      }\n      \n      // Handle dialogue advancement\n      if (input.mouse.buttons[0] && !model.userData.dialogueClicked) {\n        model.userData.dialogueClicked ": "true", "\n        model.userData.dialogueStep ": "(model.userData.dialogueStep + 1) % 4", "\n        \n        // Remove current dialogue\n        removeHTML('npc-dialogue')": null, "\n        model.userData.dialogueActive ": "false", "\n        \n        // If we've gone through all dialogues, go back to patrol\n        if (model.userData.dialogueStep ": null, "\n        }\n      } else if (!input.mouse.buttons[0]) {\n        model.userData.dialogueClicked ": "false", "\n      }\n      \n      // If player moves away, go back to chase\n      if (distanceToPlayer > model.userData.interactionRadius) {\n        model.userData.state ": "'chase'", "\n        removeHTML('npc-dialogue')": null, "\n  }\n}\n\nreturn { update }": null, "\n    model.userData.acceleration ": "new THREE.Vector3(0, -9.8, 0)", " // Gravity\n    model.userData.mass ": "1", "\n    model.userData.restitution ": "0.7", " // Bounciness\n    model.userData.friction ": "0.95", " // Friction coefficient\n    model.userData.isOnGround ": "false", "\n    model.userData.physicsInitialized ": "true", "\n    \n    // Set initial position\n    model.position.set(0, 5, 0)": null, "\n  }\n  \n  // Apply forces\n  model.userData.velocity.add(model.userData.acceleration.clone().multiplyScalar(delta))": null, "\n  \n  // Apply velocity\n  model.position.add(model.userData.velocity.clone().multiplyScalar(delta))": null, "\n  \n  // Ground collision detection (assuming ground is at y": null, "\n    \n    // Bounce when hitting the ground\n    if (model.userData.velocity.y < 0) {\n      model.userData.velocity.y ": "-model.userData.velocity.y * model.userData.restitution", "\n      \n      // Apply friction to x and z velocity when on ground\n      model.userData.velocity.x *": "model.userData.friction", "\n      model.userData.velocity.z *": "model.userData.friction", "\n      \n      // Stop bouncing if velocity is very low\n      if (Math.abs(model.userData.velocity.y) < 0.2) {\n        model.userData.velocity.y ": "0", "\n        model.userData.isOnGround ": "true", "\n      }\n    }\n  } else {\n    model.userData.isOnGround ": "false", "\n  }\n  \n  // Apply force when spacebar is pressed\n  if (input.keys[' '] && model.userData.isOnGround) {\n    model.userData.velocity.y ": "5", " // Jump force\n    model.userData.isOnGround ": "false", "\n  }\n  \n  // Apply horizontal forces with WASD\n  const moveForce ": "10 * delta", "\n  if (input.keys.w) {\n    model.userData.velocity.z -": "moveForce", "\n  }\n  if (input.keys.s) {\n    model.userData.velocity.z +": "moveForce", "\n  }\n  if (input.keys.a) {\n    model.userData.velocity.x -": "moveForce", "\n  }\n  if (input.keys.d) {\n    model.userData.velocity.x +": "moveForce", "\n  }\n  \n  // Rotate model based on movement direction\n  if (Math.abs(model.userData.velocity.x) > 0.1 || Math.abs(model.userData.velocity.z) > 0.1) {\n    const movementDirection ": "new THREE.Vector2(model.userData.velocity.x, model.userData.velocity.z).normalize()", "\n    const targetRotation ": "Math.atan2(movementDirection.x, -movementDirection.y)", "\n    scene.userData.timeOfDay ": "0", " // 0-24 hours\n    scene.userData.dayDuration ": "300", " // seconds for a full day/night cycle\n    scene.userData.timeSpeed ": "24 / scene.userData.dayDuration", " // hours per second\n    \n    // Create sun\n    const sunLight ": "new THREE.DirectionalLight(0xffffcc, 1)", "\n    sunLight.name ": "'sunLight'", "\n    sunLight.castShadow ": "true", "\n    sunLight.shadow.mapSize.width ": "2048", "\n    sunLight.shadow.mapSize.height ": "2048", "\n    sunLight.shadow.camera.near ": "0.5", "\n    sunLight.shadow.camera.far ": "50", "\n    sunLight.shadow.camera.left ": "-20", "\n    sunLight.shadow.camera.right ": "20", "\n    sunLight.shadow.camera.top ": "20", "\n    sunLight.shadow.camera.bottom ": "-20", "\n    scene.add(sunLight)": null, "\n    \n    // Create moon\n    const moonLight ": "new THREE.DirectionalLight(0x8888ff, 0.5)", "\n    moonLight.name ": "'moonLight'", "\n    moonLight.castShadow ": "true", "\n    moonLight.shadow.mapSize.width ": "1024", "\n    moonLight.shadow.mapSize.height ": "1024", "\n    moonLight.shadow.camera.near ": "0.5", "\n    moonLight.shadow.camera.far ": "50", "\n    scene.add(moonLight)": null, "\n    \n    // Create ambient light\n    const ambientLight ": "new THREE.AmbientLight(0x404040, 0.2)", "\n    ambientLight.name ": "'ambientLight'", "\n    scene.add(ambientLight)": null, "\n    \n    // Create sky hemisphere light\n    const hemisphereLight ": "new THREE.HemisphereLight(0x87CEEB, 0x404040, 0.5)", "\n    hemisphereLight.name ": "'hemisphereLight'", "\n    scene.add(hemisphereLight)": null, "\n    \n    // Create UI for time display\n    createHTML(`\n      <div id": null, "\n        top: 20px": null, "\n        right: 20px": null, "\n      \">\n        <h3>Time: 00:00</h3>\n      </div>\n    `)": null, "\n  }\n  \n  // Update time of day\n  scene.userData.timeOfDay +": "scene.userData.timeSpeed * delta", "\n  if (scene.userData.timeOfDay >": null, "\n  }\n  \n  // Update time display\n  const hours ": "Math.floor(scene.userData.timeOfDay)", "\n  const minutes ": "Math.floor((scene.userData.timeOfDay - hours) * 60)", "\n  const timeDisplay ": "document.getElementById('time-display')", "\n  if (timeDisplay) {\n    timeDisplay.innerHTML ": "`\n      <h3>Time: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}</h3>\n    `", "\n  }\n  \n  // Calculate sun and moon positions\n  const sunAngle ": "(scene.userData.timeOfDay / 24) * Math.PI * 2 - Math.PI / 2", "\n  const moonAngle ": "sunAngle + Math.PI", "\n  \n  // Get light objects\n  const sunLight ": "scene.getObjectByName('sunLight')", "\n  const moonLight ": "scene.getObjectByName('moonLight')", "\n  const ambientLight ": "scene.getObjectByName('ambientLight')", "\n  const hemisphereLight ": "scene.getObjectByName('hemisphereLight')", "\n  \n  if (sunLight && moonLight && ambientLight && hemisphereLight) {\n    // Update sun position\n    sunLight.position.x ": "Math.cos(sunAngle) * 20", "\n    sunLight.position.y ": "Math.sin(sunAngle) * 20", "\n    sunLight.position.z ": "0", "\n    \n    // Update moon position\n    moonLight.position.x ": "Math.cos(moonAngle) * 20", "\n    moonLight.position.y ": "Math.sin(moonAngle) * 20", "\n    moonLight.position.z ": "0", "\n    \n    // Calculate sun and moon intensities based on their height\n    const sunHeight ": "Math.sin(sunAngle)", "\n    const moonHeight ": "Math.sin(moonAngle)", "\n    \n    // Sun is visible when above horizon\n    const sunIntensity ": "Math.max(0, sunHeight)", "\n    sunLight.intensity ": "sunIntensity * 1.5", "\n    \n    // Moon is visible when above horizon\n    const moonIntensity ": "Math.max(0, moonHeight) * 0.5", "\n    moonLight.intensity ": "moonIntensity", "\n    \n    // Adjust ambient light based on time of day\n    ambientLight.intensity ": "0.2 + sunIntensity * 0.3 + moonIntensity * 0.1", "\n    \n    // Adjust hemisphere light based on time of day\n    hemisphereLight.intensity ": "0.2 + sunIntensity * 0.8", "\n    \n    // Change sky color based on time of day\n    if (sunHeight > 0.2) {\n      // Day - blue sky\n      scene.background ": "new THREE.Color(0x87CEEB)", "\n      hemisphereLight.color.set(0x87CEEB)": null, "\n    } else if (sunHeight > -0.2) {\n      // Sunrise/sunset - orange sky\n      const t ": "(sunHeight + 0.2) / 0.4", " // 0 to 1\n      const skyColor ": "new THREE.Color().lerpColors(\n        new THREE.Color(0xFF7F50), // Sunset orange\n        new THREE.Color(0x87CEEB), // Day blue\n        t\n      )", "\n      scene.background ": "skyColor", "\n      hemisphereLight.color.set(skyColor)": null, "\n    } else {\n      // Night - dark blue sky\n      scene.background ": "new THREE.Color(0x0A1020)", "\n      hemisphereLight.color.set(0x0A1020)": null, "\n    }\n    \n    // Adjust sun color based on height (redder at sunrise/sunset)\n    if (sunHeight > 0 && sunHeight < 0.3) {\n      // Sunrise\n      const t ": "sunHeight / 0.3", " // 0 to 1\n      sunLight.color.lerpColors(\n        new THREE.Color(0xFF7F50), // Sunrise orange\n        new THREE.Color(0xFFFFCC), // Day white-yellow\n        t\n      )": null, "\n    } else if (sunHeight > 0.3) {\n      // Day\n      sunLight.color.set(0xFFFFCC)": null, "\n\n\n\n// ": null, "\n    model.userData.velocity ": "new THREE.Vector3(0, 0, 0)", "\n    model.userData.speed ": "5", "\n    model.userData.gravity ": "9.8", "\n    model.userData.jumpForce ": "5", "\n    model.userData.isGrounded ": "false", "\n    model.userData.collisionObjects ": "[]", "\n    \n    // Find collision objects in the scene\n    scene.traverse(object ": "> {\n      if (object.userData.isCollidable) {\n        model.userData.collisionObjects.push(object)", "\n      }\n    })": null, "\n    \n    // Create simple ground if none exists\n    if (model.userData.collisionObjects.length ": null, "\n      const groundMaterial ": "new THREE.MeshStandardMaterial({ color: 0x333333 })", "\n      const ground ": "new THREE.Mesh(groundGeometry, groundMaterial)", "\n      ground.rotation.x ": "-Math.PI / 2", "\n      ground.position.y ": "0", "\n      ground.userData.isCollidable ": "true", "\n      scene.add(ground)": null, "\n      model.userData.collisionObjects.push(ground)": null, "\n    }\n    \n    // Create UI instructions\n    createHTML(`\n      <div id": null, "\n      \">\n        <h3>Controls</h3>\n        <p>WASD - Move</p>\n        <p>Space - Jump</p>\n      </div>\n    `)": null, "\n  }\n  \n  // Apply gravity\n  if (!model.userData.isGrounded) {\n    model.userData.velocity.y -": "model.userData.gravity * delta", "\n  }\n  \n  // Handle WASD movement\n  const moveDirection ": "new THREE.Vector3(0, 0, 0)", "\n  \n  if (input.keys.w) moveDirection.z -": "1", "\n  if (input.keys.s) moveDirection.z +": "1", "\n  if (input.keys.a) moveDirection.x -": "1", "\n  if (input.keys.d) moveDirection.x +": "1", "\n  \n  // Normalize movement direction\n  if (moveDirection.length() > 0) {\n    moveDirection.normalize()": null, "\n    \n    // Set horizontal velocity based on movement direction\n    model.userData.velocity.x ": "moveDirection.x * model.userData.speed", "\n    model.userData.velocity.z ": "moveDirection.z * model.userData.speed", "\n    \n    // Rotate model to face movement direction\n    if (moveDirection.length() > 0) {\n      const targetRotation ": "Math.atan2(moveDirection.x, -moveDirection.z)", "\n    }\n    \n    // Play running animation\n    playAnimation(model.name, 'run')": null, "\n  } else {\n    // Slow down horizontal movement when no keys are pressed\n    model.userData.velocity.x *": "0.9", "\n    model.userData.velocity.z *": "0.9", "\n    \n    // Play idle animation\n    playAnimation(model.name, 'idle')": null, "\n  }\n  \n  // Handle jumping\n  if (input.keys[' '] && model.userData.isGrounded) {\n    model.userData.velocity.y ": "model.userData.jumpForce", "\n  }\n  \n  // Apply velocity to position\n  model.position.x +": "model.userData.velocity.x * delta", "\n  model.position.y +": "model.userData.velocity.y * delta", "\n  \n  // Ground collision detection\n  model.userData.isGrounded ": "false", "\n  const modelHeight ": "1", " // Approximate model height\n  \n  // Check if we're below ground level\n  if (model.position.y < modelHeight / 2) {\n    model.position.y ": "modelHeight / 2", "\n    model.userData.velocity.y ": "0", "\n  }\n  \n  // Simple collision detection with other objects\n  const modelRadius ": "0.5", " // Approximate model radius\n  \n  model.userData.collisionObjects.forEach(object ": null, "\n      objectBox.applyMatrix4(object.matrixWorld)": null, "\n      \n      const modelPosition ": "new THREE.Vector3(\n        model.position.x,\n        model.position.y,\n        model.position.z\n      )", "\n      \n      if (objectBox.containsPoint(modelPosition)) {\n        // Handle collision by pushing the model out\n        // This is a simplified approach\n        const objectCenter ": "new THREE.Vector3()", "\n        objectBox.getCenter(objectCenter)": null, "\n        \n        const pushDirection ": "new THREE.Vector3()\n          .subVectors(modelPosition, objectCenter)\n          .normalize()", "\n        \n        model.position.add(pushDirection.multiplyScalar(0.1))": null, "\n        \n        // Zero out velocity in the collision direction\n        if (Math.abs(pushDirection.y) > 0.7) {\n          model.userData.velocity.y ": "0", "\n          if (pushDirection.y > 0) {\n            model.userData.isGrounded ": "true", "\n          }\n        }\n        \n        if (Math.abs(pushDirection.x) > 0.7) {\n          model.userData.velocity.x ": "0", "\n        }\n        \n        if (Math.abs(pushDirection.z) > 0.7) {\n          model.userData.velocity.z ": "0", "\n        }\n      }\n    }\n  })": null, "\n//works \n\n// ": null, " // Gravity\n    model.userData.moveSpeed ": "10", "\n    model.userData.groundRayLength ": "1.1", " // Slightly more than character height/2\n    model.userData.collisionRayCount ": "8", " // Number of rays for collision detection\n    model.userData.collisionRayLength ": "0.6", " // Length of collision rays\n    model.userData.friction ": "0.8", " // Ground friction\n    model.userData.airControl ": "0.3", " // Movement control in air\n    \n    // Create raycaster for ground detection\n    model.userData.raycaster ": "new THREE.Raycaster()", "\n      \">\n        <h3>Advanced Physics Controls</h3>\n        <p>WASD - Move</p>\n        <p>Space - Jump</p>\n        <p>Shift - Sprint</p>\n      </div>\n    `)": null, "\n  }\n  \n  // Get movement input\n  const moveDirection ": "new THREE.Vector3(0, 0, 0)", "\n    \n    // Rotate model to face movement direction\n    const targetRotation ": "Math.atan2(moveDirection.x, -moveDirection.z)", "\n    \n    // Play appropriate animation\n    if (model.userData.isGrounded) {\n      if (input.keys.shift) {\n        playAnimation(model.name, 'run')": null, "\n      } else {\n        playAnimation(model.name, 'walk')": null, "\n      }\n    }\n  } else if (model.userData.isGrounded) {\n    playAnimation(model.name, 'idle')": null, "\n  }\n  \n  // Ground detection using raycasting\n  model.userData.raycaster.set(\n    model.position.clone().add(new THREE.Vector3(0, 0.1, 0)), // Start slightly above model\n    new THREE.Vector3(0, -1, 0) // Ray direction: downward\n  )": null, "\n  \n  const intersects ": "model.userData.raycaster.intersectObjects(scene.children, true)", "\n  \n  // Check if we're on the ground\n  const wasGrounded ": "model.userData.isGrounded", "\n  model.userData.isGrounded ": "false", "\n  \n  for (let i ": "0", " i < intersects.length": null, " i++) {\n    if (intersects[i].distance < model.userData.groundRayLength && \n        intersects[i].object !": null, "\n      \n      // Snap to ground\n      if (model.userData.velocity.y <": null, "\n        model.userData.velocity.y ": "0", "\n      }\n      \n      break": null, "\n    }\n  }\n  \n  // Play landing animation when hitting ground\n  if (!wasGrounded && model.userData.isGrounded) {\n    playAnimation(model.name, 'land')": null, "\n    setTimeout(() ": "> {\n      if (model.userData.isGrounded) {\n        playAnimation(model.name, 'idle')", "\n      }\n    }, 300)": null, "\n  }\n  \n  // Apply movement force\n  if (moveDirection.length() > 0) {\n    const controlFactor ": "model.userData.isGrounded ? 1 : model.userData.airControl", "\n    const speedMultiplier ": "input.keys.shift ? 2 : 1", "\n    \n    // Apply movement force\n    model.userData.velocity.x +": "moveDirection.x * model.userData.moveSpeed * controlFactor * delta * speedMultiplier", "\n    model.userData.velocity.z +": "moveDirection.z * model.userData.moveSpeed * controlFactor * delta * speedMultiplier", "\n  }\n  \n  // Apply friction when on ground\n  if (model.userData.isGrounded) {\n    model.userData.velocity.x *": "model.userData.friction", "\n    \n    // Prevent sliding when velocity is very low\n    if (Math.abs(model.userData.velocity.x) < 0.01) model.userData.velocity.x ": "0", "\n    if (Math.abs(model.userData.velocity.z) < 0.01) model.userData.velocity.z ": "0", "\n  }\n  \n  // Apply gravity\n  if (!model.userData.isGrounded) {\n    model.userData.velocity.add(model.userData.acceleration.clone().multiplyScalar(delta))": null, "\n  }\n  \n  // Horizontal collision detection using raycasting\n  const horizontalCollision ": null, " i < model.userData.collisionRayCount": null, " i++) {\n      const angle ": "(i / model.userData.collisionRayCount) * Math.PI * 2", "\n      const rayDirection ": "new THREE.Vector3(\n        Math.sin(angle),\n        0,\n        Math.cos(angle)\n      )", "\n      \n      // Only check rays that are in the general direction of movement\n      if (rayDirection.dot(direction) > 0.3) {\n        model.userData.raycaster.set(\n          model.position.clone(),\n          rayDirection\n        )": null, "\n        \n        const intersects ": "model.userData.raycaster.intersectObjects(scene.children, true)", "\n        \n        for (let j ": "0", " j < intersects.length": null, " j++) {\n          if (intersects[j].distance < model.userData.collisionRayLength && \n              intersects[j].object !": null, "\n            \n            // Project velocity onto collision plane\n            const dot ": "model.userData.velocity.dot(collisionNormal)", "\n            model.userData.velocity.sub(collisionNormal.multiplyScalar(dot))": null, "\n            \n            // Move model away from collision\n            const pushDistance ": "model.userData.collisionRayLength - intersects[j].distance", "\n            model.position.add(collisionNormal.multiplyScalar(pushDistance))": null, "\n            \n            return true": null, "\n          }\n        }\n      }\n    }\n    return false": null, "\n  }": null, "\n  \n  // Calculate movement direction for collision detection\n  const movementDirection ": "new THREE.Vector3(\n    model.userData.velocity.x,\n    0,\n    model.userData.velocity.z\n  ).normalize()", "\n  \n  // Check for collisions\n  if (movementDirection.length() > 0) {\n    horizontalCollision(movementDirection)": null, "\n  \n  // Terminal velocity\n  const terminalVelocity ": "20", "\n  if (model.userData.velocity.y < -terminalVelocity) {\n    model.userData.velocity.y ": "-terminalVelocity", "\n  }\n  \n  // Display debug info\n  createHTML(`\n    <div id": null, "\n      top: 20px": null, "\n      left: 20px": null, "\n      background-color: rgba(0, 0, 0, 0.5)": null, "\n      color: white": null, "\n      padding: 5px": null, "\n      font-family: monospace": null, "\n      font-size: 12px": null, "\n    \">\n      <p>Position: ${model.position.x.toFixed(2)}, ${model.position.y.toFixed(2)}, ${model.position.z.toFixed(2)}</p>\n      <p>Velocity: ${model.userData.velocity.x.toFixed(2)}, ${model.userData.velocity.y.toFixed(2)}, ${model.userData.velocity.z.toFixed(2)}</p>\n      <p>Grounded: ${model.userData.isGrounded ? 'Yes' : 'No'}</p>\n    </div>\n  `)": null}
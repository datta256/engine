 {"engineshit": "import { Canvas, useFrame } from '@react-three/fiber'", "\nimport { Grid, OrbitControls, TransformControls } from '@react-three/drei'": null, "\nimport { useRef, useState, useEffect } from 'react'": null, "\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'": null, "\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader'": null, "\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader'": null, "\nimport * as THREE from 'three'": null, "\nimport CodeMirror from '@uiw/react-codemirror'": null, "\nimport { javascript } from '@codemirror/lang-javascript'": null, "\nimport OpenAI from \"openai\"": null, "\nimport { loadScriptExamples } from './scriptExamplesLoader'": null, "\n\n// Initialize OpenAI client\nconst openai ": "new OpenAI({\n  baseURL: \"https://ejs44fyotzsjtt7x.us-east-1.aws.endpoints.huggingface.cloud/v1/\",\n  apiKey: \"hf_XXXXX\",\n  dangerouslyAllowBrowser: true  // Enable browser usage\n})", "\n\n\n\n// AI Personality prompt for script generation\nconst AI_PERSONALITY ": "", "\n\n// Default script templates\nconst DEFAULT_MODEL_SCRIPT ": "// Model Script\n// Available variables and utilities:\n// - model: The current model object (THREE.Object3D)\n// - scene: The scene object (THREE.Scene)\n// - THREE: The Three.js library\n// - getModelByName(name): Function to get other models by name\n// - getAnimationsForModel(modelName): Function to get animations for a model\n// - playAnimation(modelName, animationName): Function to play an animation\n// - stopAnimation(modelName): Function to stop all animations for a model\n// - createHTML(html): Function to create and add HTML elements to the overlay\n// - removeHTML(id): Function to remove HTML elements from the overlay\n// - input: Input state object (keys, mouse)\n// - delta: Time since last frame\n\nfunction update(model, scene, THREE, getModelByName, getAnimationsForModel, playAnimation, stopAnimation, createHTML, removeHTML, input, delta) {\n  // Play idle animation when W is pressed, stop when released\n  if (input.keys.w) {\n    playAnimation(model.name, 'idle')", "\n  } else {\n    stopAnimation(model.name)": null, "\n  }\n\n  // Optional: Move the model when animating\n  if (input.keys.w) {\n    model.position.z -": "delta * 5", " // Move forward while animating\n  }\n}\n\nreturn { update }": null, "\n\nconst DEFAULT_SCENE_SCRIPT ": null, "\n      top: 10px": null, "\n      left: 10px": null, "\n      color: white": null, "\n      font-family: Arial": null, "\n    \">\n      <h2>Game Status</h2>\n      <p>Press SPACE to start</p>\n    </div>\n  \\)": null, "\n\n  // Example: Make enemies chase the player\n  const player ": "getModelByName('player.glb')", "\n  const enemy ": "getModelByName('enemy.glb')", "\n  \n  if (player && enemy) {\n    // Get the direction to the player\n    const direction ": "new THREE.Vector3()\n      .subVectors(player.position, enemy.position)\n      .normalize()", "\n    \n    // Move enemy towards player\n    enemy.position.x +": "direction.x * 2 * delta", "\n    enemy.position.z +": "direction.z * 2 * delta", "\n    \n    // Calculate distance to player\n    const distance ": "player.position.distanceTo(enemy.position)", "\n    \n    // Play appropriate animation based on distance\n    if (distance < 2) {\n      // Attack when close\n      playAnimation('enemy.glb', 'attack')": null, "\n      \n      // Create attack UI notification\n      createHTML(\\\n        <div id": null, "\n          top: 20px": null, "\n          left: 50%": null, "\n          transform: translateX(-50%)": null, "\n          background-color: rgba(255, 0, 0, 0.7)": null, "\n          color: white": null, "\n          padding: 10px 20px": null, "\n          border-radius: 5px": null, "\n          font-family: Arial": null, "\n          pointer-events: none": null, "\n        \">\n          Enemy Attacking!\n        </div>\n      \\)": null, "\n      \n      // Remove notice after 2 seconds\n      enemy.userData.noticeTimer ": "(enemy.userData.noticeTimer || 0) + delta", "\n      if (enemy.userData.noticeTimer > 2) {\n        removeHTML('attackNotice')": null, "\n        enemy.userData.noticeTimer ": "0", "\n      }\n    } else {\n      // Chase when far\n      playAnimation('enemy.glb', 'run')": null, "\n      \n      // Remove notice if it exists\n      removeHTML('attackNotice')": null, "\n      enemy.userData.noticeTimer ": "0", "\n    }\n    \n    // Make enemy face the player\n    enemy.lookAt(player.position)": null, "\n  }\n}\n\nreturn { update }": null, " \n\n// Input management\nconst useInput ": null, "\n\n  useEffect(() ": null, "\n    }": null, "\n\n    const handleKeyUp ": null, "\n\n    const handleMouseMove ": null, "\n      input.mouse.y ": "e.clientY", "\n\n    const handleMouseDown ": null, "\n\n    const handleMouseUp ": null, "\n\n    window.addEventListener('keydown', handleKeyDown)": null, "\n    window.addEventListener('keyup', handleKeyUp)": null, "\n    window.addEventListener('mousemove', handleMouseMove)": null, "\n    window.addEventListener('mousedown', handleMouseDown)": null, "\n    window.addEventListener('mouseup', handleMouseUp)": null, "\n\n    return () ": "> {\n      window.removeEventListener('keydown', handleKeyDown)", "\n      window.removeEventListener('keyup', handleKeyUp)": null, "\n      window.removeEventListener('mousemove', handleMouseMove)": null, "\n      window.removeEventListener('mousedown', handleMouseDown)": null, "\n      window.removeEventListener('mouseup', handleMouseUp)": null, "\n  }, [input])": null, "\n\n  return input": null, "\n}": null, "\n\n// Scene component to handle animations and model rendering\nconst Scene ": null, "\n  const orbitRef ": "useRef()", "\n  const input ": "useInput()", "\n  const overlayRef ": "useRef(null)", "\n  \n  // Add refs for script caching\n  const sceneScriptRef ": "useRef({ script: '', module: null })", "\n  const modelScriptsRef ": "useRef([])", "\n\n  // Create overlay div for HTML elements if it doesn't exist\n  useEffect(() ": null, "\n      overlay.id ": "'scriptOverlay'", "\n      overlay.style.position ": "'absolute'", "\n      overlay.style.top ": "'0'", "\n      overlay.style.left ": "'0'", "\n      overlay.style.width ": "'100%'", "\n      overlay.style.height ": "'100%'", "\n      overlay.style.pointerEvents ": "'none'", "\n      overlay.style.zIndex ": "'1000'", "\n      document.body.appendChild(overlay)": null, "\n      overlayRef.current ": "overlay", "\n    }\n    return () ": "> {\n      if (overlayRef.current) {\n        document.body.removeChild(overlayRef.current)", "\n      }\n    }": null, "\n  }, [])": null, "\n\n  // Effect to handle script changes\n  useEffect(() ": null, "\n    }\n    \n    // Reset scene script cache if changed\n    if (sceneScript !": null, "\n    }\n    \n    // Reset model script caches if changed\n    modelScripts.forEach((script, index) ": null, "\n      }\n    })": null, "\n  }, [sceneScript, modelScripts, isEditMode])": null, "\n\n  const getModelByName ": null, "\n    return index !": null, "\n  }": null, "\n\n  const getAnimationsForModel ": null, "\n    return model?.animations || []": null, "\n\n  const playAnimation ": null, "\n    \n    // Find the model by name or use the active model if modelName matches\n    let targetModel ": "null", "\n    if (activeModel && modelName ": null, "\n    } else {\n      targetModel ": "getModelByName(modelName)", "\n    }\n\n    if (!targetModel) {\n      console.log(\"No model found for\", modelName)": null, "\n      return": null, "\n    }\n\n    // Get animations either from model or active model\n    const modelAnimations ": "targetModel.animations || animations", "\n    if (!modelAnimations || modelAnimations.length ": null, "\n    }\n\n    const animation ": null, "\n    if (!animation) {\n      console.log(\"Animation not found:\", animationName, \"for model\", modelName)": null, "\n    }\n\n    console.log(\"Playing animation:\", animationName, \"for model\", modelName)": null, "\n    mixer.stopAllAction()": null, "\n    const action ": "mixer.clipAction(animation, targetModel)", "\n    action.reset()": null, "\n    action.setEffectiveTimeScale(1)": null, "\n    action.setEffectiveWeight(1)": null, "\n    action.clampWhenFinished ": "true", "            \n    action.play()": null, "\n\n    // Call the callback to update parent state\n    if (onPlayAnimation) {\n      onPlayAnimation(modelName, animationName)": null, "\n    }\n  }": null, "\n\n  const stopAnimation ": null, "\n    }\n\n    // Call the callback to update parent state\n    if (onStopAnimation) {\n      onStopAnimation(modelName)": null, "\n\n  const createHTML ": null, "\n    \n    // Create a temporary container\n    const temp ": "document.createElement('div')", "\n    temp.innerHTML ": "html", "\n    \n    // Get the first element (our actual content)\n    const element ": "temp.firstElementChild", "\n    \n    // Add it to the overlay\n    if (element) {\n      overlayRef.current.appendChild(element)": null, "\n\n  const removeHTML ": null, "\n    if (element && overlayRef.current) {\n      overlayRef.current.removeChild(element)": null, "\n\n  useFrame((state, delta) ": "> {\n    // Update mixer regardless of mode\n    if (mixer) {\n      mixer.update(delta)", "\n    }\n\n    // Only execute scripts in play mode\n    if (!isEditMode) {\n      // Execute scene script\n      try {\n        if (sceneScript) {\n          // Use cached module if available\n          if (!sceneScriptRef.current.module) {\n            const scriptFn ": "new Function(\n              'scene',\n              'THREE',\n              'getModelByName',\n              'getAnimationsForModel',\n              'playAnimation',\n              'stopAnimation',\n              'createHTML',\n              'removeHTML',\n              'input',\n              'delta',\n              'camera',\n              \n              try {\n                ${sceneScript}\n              } catch (error) {\n                console.error('Error in scene script:', error)", "\n                return { update: () ": "> {} }", "\n              }\n              \n            )": null, "\n\n            try {\n              sceneScriptRef.current.module ": null, "\n                  return model": null, "\n                },\n                getAnimationsForModel,\n                (modelName, animName) ": "> playAnimation(modelName, animName),\n                stopAnimation,\n                createHTML,\n                removeHTML,\n                input,\n                delta,\n                state.camera\n              )", "\n            } catch (error) {\n              console.error('Error initializing scene script:', error)": null, "\n              sceneScriptRef.current.module ": null, "\n            }\n          }\n\n          // Execute cached module\n          if (typeof sceneScriptRef.current.module ": null, "\n            } catch (error) {\n              console.error('Error executing scene script update:', error)": null, "\n            }\n          }\n        }\n\n        // Execute model scripts\n        uploadedModels.forEach((model, index) ": null, "\n          if (script) {\n            try {\n              // Use cached module if available\n              if (!modelScriptsRef.current[index]?.module) {\n                const scriptFn ": "new Function(\n                  'model',\n                  'scene',\n                  'THREE',\n                  'getModelByName',\n                  'getAnimationsForModel',\n                  'playAnimation',\n                  'stopAnimation',\n                  'createHTML',\n                  'removeHTML',\n                  'input',\n                  'delta',\n                  'camera',\n                  \n                  try {\n                    ${script}\n                  } catch (error) {\n                    console.error('Error in model script:', error)", "\n                    return { update: () ": "> {} }", "\n                  }\n                  \n                )": null, "\n\n                if (!modelScriptsRef.current[index]) {\n                  modelScriptsRef.current[index] ": "{ script, module: null }", "\n                }\n\n                try {\n                  modelScriptsRef.current[index].module ": null, "\n                      return model": null, "\n                    },\n                    getAnimationsForModel,\n                    (modelName, animName) ": "> playAnimation(modelName, animName),\n                    stopAnimation,\n                    createHTML,\n                    removeHTML,\n                    input,\n                    delta,\n                    state.camera\n                  )", "\n                } catch (error) {\n                  console.error(Error initializing model script ${index}:, error)": null, "\n                  modelScriptsRef.current[index].module ": null, "\n                }\n              }\n\n              // Execute cached module\n              const cachedModule ": "modelScriptsRef.current[index]?.module", "\n              if (typeof cachedModule ": null, "\n                } catch (error) {\n                  console.error(Error executing model script ${index} update:, error)": null, "\n                }\n              }\n            } catch (error) {\n              console.error(Error in model script ${index}:, error)": null, "\n            }\n          }\n        })": null, "\n      } catch (error) {\n        console.error('Error in script execution:', error)": null, "\n      }\n    }\n\n    // Disable OrbitControls while using TransformControls\n    if (transformRef.current) {\n      const controls ": "transformRef.current", "\n      const callback ": null, "\n      }": null, "\n      \n      controls.addEventListener('dragging-changed', callback)": null, "\n      return () ": "> controls.removeEventListener('dragging-changed', callback)", "\n    }\n  })": null, "\n\n  return (\n    <>\n      <ambientLight intensity": null, "\n\nconst AnimationCanvas ": null, "\n\n// Add conversation memory system\nconst ConversationMemory ": null, "\n  const MAX_CONVERSATIONS ": "50", "\n  \n  // Initialize or load existing conversations\n  const loadConversations ": null, "\n      return stored ? JSON.parse(stored) : []": null, "\n    } catch (error) {\n      console.error('Error loading conversations:', error)": null, "\n      return []": null, "\n  \n  // Save conversations to localStorage\n  const saveConversations ": null, "\n    } catch (error) {\n      console.error('Error saving conversations:', error)": null, "\n  \n  // Add a new conversation entry\n  const addConversation ": null, "\n    \n    // Create new conversation entry\n    const newEntry ": null, "\n    \n    // Add to beginning of array and limit size\n    conversations.unshift(newEntry)": null, "\n    if (conversations.length > MAX_CONVERSATIONS) {\n      conversations.pop()": null, "\n    }\n    \n    saveConversations(conversations)": null, "\n    return newEntry": null, "\n  \n  // Simple semantic search using term frequency\n  const searchConversations ": null, "\n    \n    const conversations ": "loadConversations()", "\n    if (conversations.length ": null, "\n    \n    // Tokenize query into terms\n    const queryTerms ": null, "\n    if (queryTerms.length ": null, "\n    \n    // Score each conversation\n    const scoredConversations ": null, "\n      let score ": "0", "\n      \n      // Count term occurrences\n      queryTerms.forEach(term ": null, "\n        const matches ": "text.match(regex)", "\n        if (matches) {\n          score +": "matches.length", "\n        }\n      })": null, "\n      \n      return { ...conversation, score }": null, "\n    })": null, "\n    \n    // Sort by score and return top results\n    return scoredConversations\n      .filter(item ": null, "\n  \n  // Get all conversations\n  const getAllConversations ": null, "\n  \n  // Clear all conversations\n  const clearConversations ": null, "\n  \n  return {\n    addConversation,\n    searchConversations,\n    getAllConversations,\n    clearConversations\n  }": null, "\n\n// Initialize the conversation memory\nconst conversationMemory ": "ConversationMemory()", "\n\nconst Engine ": null, "\n  const [uploadedModels, setUploadedModels] ": "useState([])", "\n  const [modelNames, setModelNames] ": "useState([])", " // Store names for models\n  const [activeModel, setActiveModel] ": "useState(null)", "\n  const [activeModelIndex, setActiveModelIndex] ": "useState(null)", " // Track active model index\n  const [transformMode, setTransformMode] ": "useState('translate')", "\n  const [isEditMode, setIsEditMode] ": "useState(true)", "\n  const [isCameraLocked, setIsCameraLocked] ": "useState(false)", "\n  const [activeMenu, setActiveMenu] ": "useState('main')", "\n  const [animations, setAnimations] ": "useState([])", "\n  const [activeAnimation, setActiveAnimation] ": "useState(null)", "\n  const [animationName, setAnimationName] ": "useState('')", "\n  const [mixer, setMixer] ": "useState(null)", "\n  const [editingModelName, setEditingModelName] ": "useState('')", "\n  const [modelScripts, setModelScripts] ": "useState([])", "\n  const [sceneScript, setSceneScript] ": "useState(DEFAULT_SCENE_SCRIPT)", "\n  const [selectedScript, setSelectedScript] ": "useState(null)", " // 'scene' or model index\n  const [chatMessage, setChatMessage] ": "useState('')", "\n  const [chatMessages, setChatMessages] ": "useState([])", "\n\n  // Add new state for script generation\n  const [isGeneratingScript, setIsGeneratingScript] ": "useState(false)", "\n\n  // Add state for search query\n  const [searchQuery, setSearchQuery] ": "useState('')", "\n\n  // Add state for script examples\n  const [scriptExamples, setScriptExamples] ": "useState({ modelScripts: [], sceneScripts: [] })", "\n  const [examplesLoaded, setExamplesLoaded] ": "useState(false)", "\n\n  // Load script examples on component mount\n  useEffect(() ": null, "\n      setScriptExamples(examples)": null, "\n      setExamplesLoaded(true)": null, "\n    \n    loadExamples()": null, "\n  \n  // Function to find relevant examples based on the prompt\n  const findRelevantExamples ": null, "\n    \n    // Simple keyword matching for relevance\n    const keywords ": null, "\n    \n    // Score each example\n    const scoredExamples ": null, "\n      \n      keywords.forEach(keyword ": null, "\n      \n      return { ...example, score }": null, "\n    \n    // Sort by score and return top results\n    return scoredExamples\n      .filter(item ": null, "\n  \n  useEffect(() ": null, "\n    return () ": "> {\n      window.removeEventListener('keydown', handleKeyDown)", "\n\n  const handleFileUpload ": null, "\n    files.forEach(file ": null, "\n      reader.onload ": null, "\n        loadModel(file.name, content)": null, "\n      reader.readAsArrayBuffer(file)": null, "\n\n  const loadModel ": null, "\n    if (fileName.endsWith('.glb') || fileName.endsWith('.gltf')) {\n      loader ": "new GLTFLoader()", "\n      loader.parse(content, '', (object) ": "> {\n        resizeModel(object.scene || object)", "\n        const model ": "object.scene || object", "\n        \n        // Store animations on the model\n        if (object.animations && object.animations.length > 0) {\n          model.animations ": "object.animations", "\n        }\n        \n        setUploadedModels(prev ": "> [...prev, model])", "\n        setModelNames(prev ": "> [...prev, fileName])", "\n        setModelScripts(prev ": "> [...prev, DEFAULT_MODEL_SCRIPT])", " // Add default script\n        setAnimations(object.animations || [])": null, "\n\n        // Create mixer for the first model with animations\n        if (!mixer && object.animations && object.animations.length > 0) {\n          const newMixer ": "new THREE.AnimationMixer(model)", "\n          setMixer(newMixer)": null, "\n        }\n      }, (error) ": "> {\n        console.error('Error loading GLTF model:', error)", "\n      })": null, "\n    } else if (fileName.endsWith('.obj')) {\n      loader ": "new OBJLoader()", "\n      loader.load(URL.createObjectURL(new Blob([content])), (object) ": "> {\n        resizeModel(object)", "\n        setUploadedModels(prev ": "> [...prev, object])", " // Add model name\n      }, undefined, (error) ": "> {\n        console.error('Error loading OBJ model:', error)", "\n    } else if (fileName.endsWith('.fbx')) {\n      loader ": "new FBXLoader()", "\n    } else {\n      console.error('Unsupported file type')": null, "\n\n  const resizeModel ": null, "\n    const size ": "box.getSize(new THREE.Vector3())", "\n    const maxSize ": "Math.max(size.x, size.y, size.z)", "\n\n    if (maxSize > 1) {\n      const scale ": "1 / maxSize", "\n      model.scale.set(scale, scale, scale)": null, "\n    }\n    model.position.set(0, 0, 0)": null, "\n\n  const handleModelClick ": null, "\n    setActiveModelIndex(index)": null, "\n    setAnimations(model.animations || [])": null, "\n    \n    // Create new mixer if we don't have one and model has animations\n    if (!mixer && model.animations && model.animations.length > 0) {\n      const newMixer ": "new THREE.AnimationMixer(model)", "\n      setMixer(newMixer)": null, "\n\n  const toggleEditMode ": null, "\n\n  const handleAnimationSelect ": null, "\n    setAnimationName(animation.name || '')": null, " // Set the current name for editing\n  }": null, "\n\n  const handleAnimationRename ": null, " // Rename the animation\n      setAnimations([...animations])": null, " // Update the state to trigger re-render\n    }\n  }": null, "\n\n  const stopAllAnimations ": null, "\n\n  const deleteModel ": null, "\n    const newNames ": "[...modelNames]", "\n    newModels.splice(index, 1)": null, "\n    newNames.splice(index, 1)": null, "\n    setUploadedModels(newModels)": null, "\n    setModelNames(newNames)": null, "\n    if (activeModelIndex ": null, "\n      setActiveModelIndex(null)": null, "\n      setMixer(null)": null, "\n      setAnimations([])": null, "\n\n  const duplicateModel ": null, "\n    const clonedModel ": "modelToClone.clone()", "\n    const newName ": "${modelNames[index]} (copy)", "\n    setUploadedModels([...uploadedModels, clonedModel])": null, "\n    setModelNames([...modelNames, newName])": null, "\n\n  const renameModel ": null, "\n    newNames[index] ": "newName", "\n    setEditingModelName('')": null, "\n\n  const handleScriptChange ": null, "\n    } else if (typeof selectedScript ": null, "\n      newScripts[selectedScript] ": "value", "\n      setModelScripts(newScripts)": null, "\n\n  const handlePlayAnimation ": null, "\n    if (!model || !model.animations) {\n      console.log(\"No model or animations found\")": null, "\n    if (!animation) {\n      console.log(\"Animation not found:\", animationName)": null, "\n    }\n\n    // Create mixer if it doesn't exist\n    if (!mixer) {\n      console.log(\"Creating new mixer\")": null, "\n      const newMixer ": "new THREE.AnimationMixer(model)", " // Return and let the next frame handle playing the animation\n    }\n\n    // Play the animation\n    console.log(\"Playing animation:\", animationName)": null, "\n    action.play()": null, "\n\n  const handleStopAnimation ": null, "\n\n  // Add edit button overlay\n  useEffect(() ": null, "\n      editButton.innerHTML ": null, "\n          right: 20px": null, "\n          cursor: pointer": null, "\n          z-index: 2000": null, "\n          background: rgba(0, 0, 0, 0.5)": null, "\n          padding: 10px": null, "\n          transition: all 0.3s ease": null, "\n        \"\n        onmouseover": null, "\n      document.body.appendChild(editButton)": null, "\n\n      const handleEditMode ": null, "\n\n      document.addEventListener('editMode', handleEditMode)": null, "\n\n      return () ": "> {\n        document.removeEventListener('editMode', handleEditMode)", "\n        if (editButton.parentNode) {\n          editButton.parentNode.removeChild(editButton)": null, "\n        }\n      }": null, "\n    }\n  }, [isEditMode])": null, "\n\n  // Add chat message handler\n  const handleSendMessage ": null, "\n      setChatMessage('')": null, "\n\n  // Add chat keypress handler\n  const handleChatKeyPress ": null, "\n      handleSendMessage()": null, "\n\n  // Function to get scene state as JSON\n  const getSceneState ": null, "\n    return JSON.stringify(sceneState, null, 2)": null, "\n\n  // Update the generateScript function to use examples as context\n  const generateScript ": null, "\n    try {\n      const sceneState ": "getSceneState()", "\n      \n      // Search for relevant past conversations\n      const relevantConversations ": "conversationMemory.searchConversations(prompt)", "\n      \n      // Format relevant conversations as context\n      let conversationContext ": "''", "\n      if (relevantConversations.length > 0) {\n        conversationContext ": null, "\n      }\n      \n      // Find relevant examples from our examples library\n      const scriptType ": null, "\n      const relevantExamples ": "findRelevantExamples(prompt, scriptType)", "\n      \n      // Format examples as context\n      let examplesContext ": "''", "\n      if (relevantExamples.length > 0) {\n        examplesContext ": null, "\n      }\n      \n      const messages ": "[\n        { role: \"system\", content: AI_PERSONALITY },\n        { \n          role: \"user\", \n          content: Scene state: ${sceneState}\\n\\n${examplesContext ? examplesContext + '\\n\\n' : ''}${conversationContext ? conversationContext + '\\n\\n' : ''}Generate a script that: ${prompt} \n        }\n      ]", "\n\n      const stream ": "await openai.chat.completions.create({\n        model: \"deepseek-ai/DeepSeek-R1\",\n        messages,\n        temperature: 0.1,\n        max_tokens: 150000,\n        stream: true,\n        seed: 434898438934938\n      })", "\n\n      let generatedScript ": "''", "\n      for await (const chunk of stream) {\n        const content ": "chunk.choices[0]?.delta?.content || ''", "\n        generatedScript +": "content", "\n        \n        // Update the script in real-time as it's being generated\n        if (selectedScript ": null, "\n        } else if (typeof selectedScript ": null, "\n          newScripts[selectedScript] ": "generatedScript", "\n          setModelScripts(newScripts)": null, "\n        }\n      }\n      \n      // Store the conversation after successful generation\n      conversationMemory.addConversation(\n        prompt, \n        generatedScript, \n        selectedScript\n      )": null, "\n      \n    } catch (error) {\n      console.error('Error generating script:', error)": null, "\n    } finally {\n      setIsGeneratingScript(false)": null, "\n  \n  // Add a function to export examples for fine-tuning\n  const exportExamplesForFineTuning ": null, "\n    \n    // Format examples for fine-tuning\n    const formattedExamples ": null, "\n    \n    // Convert to JSONL format\n    const jsonl ": null, "\n    \n    // Create download link\n    const blob ": "new Blob([jsonl], { type: 'application/jsonl' })", "\n    const url ": "URL.createObjectURL(blob)", "\n    const a ": "document.createElement('a')", "\n    a.href ": "url", "\n    a.download ": "'script_examples_for_finetuning.jsonl'", "\n    document.body.appendChild(a)": null, "\n    a.click()": null, "\n    document.body.removeChild(a)": null, "\n    URL.revokeObjectURL(url)": null, "\n  \n  // Handle selecting a conversation from history\n  const handleSelectConversation ": null, "\n      setSceneScript(conversation.script)": null, "\n    } else {\n      // Find the model index by name\n      const modelIndex ": null, "\n      if (modelIndex !": null, "\n        const newScripts ": "[...modelScripts]", "\n        newScripts[modelIndex] ": "conversation.script", "\n        setModelScripts(newScripts)": null, "\n      }\n    }\n    \n    // Set the prompt\n    if (document.getElementById('scriptPrompt')) {\n      document.getElementById('scriptPrompt').value ": "conversation.prompt", "\n\n  return (\n    <div className": null, "\n                          generateScript(prompt)": null, "\n                        }}\n                        disabled": null, "\n                            newNames[index] ": "e.target.value", "\n                            setModelNames(newNames)": null, "\n                          }}\n                          onBlur": null, "\n                            }\n                          }}\n                          className": null, "\n\n// Add conversation history UI to the sidebar\nconst ConversationHistory ": null, "\n  \n  const formatDate ": null, "\n    return date.toLocaleString()": null, "\n  \n  const truncateText ": null, "\n    return text.substring(0, maxLength) + '...'": null, "\n  \n  return (\n    <div className": null, "\n            setConversations([])": null, "\n          }}\n          className": null, "\n\nexport default Engine": null}